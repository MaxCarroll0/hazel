# Basics #

type Option = None + Some(?) in

let fst: (?, ?) -> ? = fun a, b -> a in
let snd: (?, ?) -> ? = fun a, b -> b in

let not: Bool -> Bool = fun b -> !b in

let bool_eq: (Bool, Bool) -> Bool =
  fun a, b -> a && b \/ !a && !b in


# Lists #

# Add an element to the front of a list. #
let List.cons: (?, [?]) -> [?] =
  fun x, xs -> x::xs in

# Determine the length of a list. #
let List.length: [?] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + List.length(xs) end in

# Extract the head of the list. #
let List.hd: [?] -> ? =
  fun l -> 
    case l  
    | [] => ?
    | x::xs => x end in

# Extract the rest of the list. #
let List.tl: [?] -> [?] =
  fun l ->
    case l 
    | [] => ?
    | x::xs => xs end in

# Determine if a list is empty. #
let List.is_empty: [?] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

let List.nth: ([?], Int) -> ? =
  fun xs, n ->
    case xs, n
    | x::_, 0 => x
    | _::xs, n => List.nth(xs, n - 1)
    | [], _ => ? end in

# Reverse a List. #
let List.rev: [?] -> [?] =
  fun l -> 
    let go: ([?], [?]) -> [?] =
      fun xs, acc -> 
        case xs 
        | [] => acc 
        | x::xs => go(xs, x::acc) end in
   go(l, []) in

# Initialize a list with a given length using an initializer function #
let List.init: (Int, Int -> ?) -> [?] =
  fun len, f ->
    let go: (Int, [?]) -> [?] =
      fun idx, xs ->
        if idx < len 
        then go(idx+ 1, xs @ [f(idx)])   
        else xs in
    go(0, []) in

# Check if two lists are equal #
let List.equal: (? -> Bool, [?], [?]) -> Bool =
  fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => p(x, y) && List.equal(p, xs, ys)
    | _ => false end in

let List.eq = List.equal in

# Reduce a list from the left. #
let List.fold_left: ((?, ?)-> ?, ?, [?])-> ?   =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => List.fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let List.fold_right: ((?, ?)-> ?, [?], ?)-> ? =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, List.fold_right(f, tl, acc)) end in

let List.fold_left2: ((?, ?, ?) -> ?, ?, [?], [?]) -> [?] = 
  fun f, acc, xs, ys ->
    case xs, ys
    | [], [] => acc
    | x::xs, y::ys =>
      List.fold_left2(f, f(acc, x, y), xs, ys)
    | _ => ? end in

let List.fold_right2: ((?, ?, ?) -> ?, [?], [?], ?) -> [?] =
  fun f, acc, xs, ys ->
    case xs, ys
    | [], [] => acc
    | x::xs, y::ys =>
       f(x, y, List.fold_right2(f, xs, ys, acc))
    | _ => ? end in

let List.map: (? -> ?, [?]) -> ? =
  fun f, xs ->
    List.fold_right(fun x, acc -> f(x)::acc, xs, []) in

let List.map2: ((?,?) -> ?, [?], [?]) -> [?] =
  fun f, xs, ys ->
    List.fold_left2(
      fun x, y, acc -> f(x, y)::acc, xs, ys, []) in

# Keep elements that satisfy the test. #
let List.filter: (? -> Bool, [?]) -> [?] =
  fun p, xs ->
    case xs
    | [] => []
    | x::xs =>
      let xs = List.filter(p, xs) in 
      if p(x) then x :: xs else xs end in

let List.append: (([?], [?]) -> [?]) =
  fun xs, ys -> List.fold_right(List.cons, xs, ys) in

let List.concat: [[?]] -> [?] =
  fun xss -> List.fold_right(List.append, xss, [])  in

let List.flatten = List.concat in

let List.mapi: ((Int, ?) -> ?, [?]) -> [?] =
  fun f, xs ->
    let go: ? -> ? = fun idx, xs ->
      case xs
      | [] => []
      | hd::tl => f(idx, hd)::go(idx + 1, tl) end in
    go(0, xs) in

let List.filteri: ((Int, ?) -> Bool, [?]) -> [?] =
  fun f, xs ->
    List.concat(List.mapi(
      fun i, x -> if f(i, x) then [x] else [], xs)) in

let List.exists: (? -> Bool, [?]) -> Bool =
  fun p, xs ->
    case xs
    | [] => false
    | x::xs => p(x) \/ List.exists(p, xs) end in

let List.for_all: (? -> Bool, [?]) -> Bool =
  fun p, xs -> not(List.exists(fun x -> not(p(x)), xs)) in

let List.mem = fun eq, xs, y ->
  List.exists(fun x -> eq(x, y), xs) in

let List.filter_map: ((? -> Option), [?]) -> [?] =
  fun f, xs ->
    List.fold_right(
      fun x, acc ->
        case f(x)
        | None => acc
        | Some(y) => y::acc end,
      xs,
      []) in

let List.concat_map: ((? -> [?]), [?]) -> [?] =
  fun f, xs ->
    List.fold_right(
      fun x, acc -> List.append(f(x), acc),
      xs,
      []) in
  
let List.for_all2: (((?, ?) -> Bool), [?], [?]) -> Bool =
  fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => p(x, y) && List.for_all2(p, xs, ys)
    | _ => false end in
      
let List.exists2: (((?, ?) -> Bool), [?], [?]) -> Bool =
  fun p, xs, ys ->
    case xs, ys
    | [], [] => false
    | x::xs, y::ys => p(x, y) \/ List.exists2(p, xs, ys)
    | _ => false end in

let List.find: (? -> Bool, [?]) -> Option =
  fun p, xs ->
    case xs
    | [] => None
    | x::xs => if p(x) then Some(x) else List.find(p, xs)
    end in

let List.partition: (? -> Bool, [?]) -> ([?], [?]) =
  fun p, xs ->
    List.fold_right(
      fun x, (ys, zs) ->
        if p(x) then (x::ys, zs) else (ys, x::zs),
      xs,
      ([], [])) in

let List.split: ([?], ?) -> ([?], [?]) =
  fun xs, n ->
    let go: ([?], ?, [?], [?]) -> ([?], [?]) =
      fun xs, n, ys, zs ->
        case xs, n
        | _, 0 => (List.rev(ys), zs)
        | [], _ => (List.rev(ys), [])
        | x::xs, n => go(xs, n-1, x::ys, zs @ [x]) 
        end in
    go(xs, n, [], []) in

let List.combine: ([?], [?]) -> [?] =
  fun xs, ys ->
    case xs, ys
    | [], _ => []
    | _, [] => []
    | x::xs, y::ys => (x, y)::List.combine(xs, ys) 
    end in

let List.rev_append: ([?], [?]) -> [?] = fun xs, ys ->
  let go: ([?], [?]) -> [?] = fun xs, acc ->
    case xs
    | [] => acc
    | x::xs => go(xs, x::acc) 
    end in
  go(xs, ys) in

let List.merge: ((?, ?) -> Int, [?], [?]) -> [?] =
  fun cmp, xs, ys ->
    let go: ([?], [?], [?]) -> [?] =
      fun xs, ys, acc ->
        case xs, ys
        | [], [] => List.rev(acc)
        | [], ys => List.rev_append(acc, ys)
        | xs, [] => List.rev_append(acc, xs)
        | x::xs, y::ys =>
          if cmp(x, y) <= 0 
          then go(xs, y::ys, x::acc) 
          else go(x::xs, ys, y::acc) 
        end in
    go(xs, ys, []) in
      
let List.sort: ((?, ?) ->Int, [?]) -> [?] =
  fun cmp, xs ->
    let split: [?] -> ([?], [?]) = fun xs ->
      case xs
      | [] => ([], [])
      | [x] => ([x], [])
      | x::y::ys =>
        let (xs, ys) = split(ys) in
        (x::xs, y::ys) 
      end in
    let merge_sort: [?] -> [?] = fun xs ->
      case xs
      | [] => []
      | [x] => [x]
      | _ =>
        let (left, right) = split(xs) in
        List.merge(cmp, merge_sort(left), merge_sort(right)) 
      end in
    merge_sort(xs) in

# Operator aliases #

let eq = fun a, b -> a == b in
let equal = eq in
let equals = eq in
let is = eq in
let Int.eq: (Int, Int) -> Bool = eq in
let Float.eq: (Float, Float) -> Bool = eq in
let String.eq: (String, String) -> Bool = eq in
let Bool.eq: (Bool, Bool) -> Bool = eq in

let Int.is: (Int, Int) -> Bool = Int.eq in
let Float.is: (Float, Float) -> Bool = Float.eq in

let neq = fun a, b -> a!= b in
let notEqual = neq in
let notEquals = neq in
let Int.neq: (Int, Int) -> Bool = neq in
let Float.neq: (Float, Float) -> Bool = neq in
let String.neq: (String, String) -> Bool = neq in
let Bool.neq: (Bool, Bool) -> Bool = neq in 

let or: (Bool, Bool) -> Bool = fun a, b -> a \/ b in
let and: (Bool, Bool) -> Bool = fun a, b -> a && b in
let not: Bool -> Bool = fun a -> ! a in
let Bool.or = or in
let Bool.and = and in
let Bool.not = not in

let lt = fun a, b -> a < b in
let lte = fun a, b -> a <= b in
let gt = fun a, b -> a > b in
let gte = fun a, b -> a >= b in
let lessThan = lt in
let lessThanOrEqual = lte in
let greaterThan = gt in
let greaterThanOrEqual = gte in

let Int.lt: (Int, Int) -> Bool = lt in
let Int.lte: (Int, Int) -> Bool = lte in
let Int.gt: (Int, Int) -> Bool = gt in
let Int.gte: (Int, Int) -> Bool = gte in
let Int.lessThan = lt in
let Int.lessThanOrEqual = lte in
let Int.greaterThan = Int.gt in
let Int.greaterThanOrEqual = gte in

let Float.lt: (Float, Float) -> Bool = fun a, b -> a <. b in
let Float.lte: (Float, Float) -> Bool = fun a, b -> a <=. b in
let Float.gt: (Float, Float) -> Bool = fun a, b -> a >. b in
let Float.gte: (Float, Float) -> Bool = fun a, b -> a >=. b in
let Float.lessThan = Float.lt in
let Float.lessThanOrEqual = Float.lte in
let Float.greaterThan = Float.gt in
let Float.greaterThanOrEqual = Float.gte in

let add = fun a, b -> a + b in
let sub = fun a, b -> a - b in
let mul = fun a, b -> a * b in
let div = fun a, b -> a / b in
let exp = fun a, b -> a ** b in
let minus = sub in
let times = mul in
let plus = add in
let divide = div in
let power = exp in

let Int.add: (Int, Int) -> Int = add in
let Int.sub: (Int, Int) -> Int = sub in
let Int.mul: (Int, Int) -> Int = mul in
let Int.div: (Int, Int) -> Int = div in
let Int.exp: (Int, Int) -> Int = exp in
let Int.minus = Int.sub in
let Int.times = Int.mul in
let Int.plus: (Int, Int) -> Int = Int.add in
let Int.divide: (Int, Int) -> Int = Int.div in
let Int.power: (Int, Int) -> Int = Int.exp in

let Float.add: (Float, Float) -> Float = fun a, b -> a +. b in
let Float.sub: (Float, Float) -> Float = fun a, b -> a -. b in
let Float.mul: (Float, Float) -> Float = fun a, b -> a *. b in
let Float.div: (Float, Float) -> Float = fun a, b -> a /. b in
let Float.exp: (Float, Float) -> Float = fun a, b -> a **. b in
let Float.minus = Float.sub in
let Float.times = Float.mul in
let Float.plus: (Float, Float) -> Float = Float.add in
let Float.divide: (Float, Float) -> Float = Float.div in
let Float.power: (Float, Float) -> Float = Float.exp in

let cons: (?, [?]) -> [?] = fun hd, tl -> hd::tl in
let append: ([?],[?]) -> [?] = fun a, b -> a@b in
let List.cons = cons in
let List.concat = append in