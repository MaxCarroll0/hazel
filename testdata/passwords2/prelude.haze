# Basics #

type Option = None + Some(?) in

let fst: (?, ?) -> ? = fun a, b -> a in
let snd: (?, ?) -> ? = fun a, b -> b in

let not: Bool -> Bool = fun b -> !b in

let bool_eq: (Bool, Bool) -> Bool =
  fun a, b -> a && b \/ !a && !b in


# Lists #

# Add an element to the front of a list. #
let List.cons: (?, [?]) -> [?] =
  fun x, xs -> x::xs in

# Determine the length of a list. #
let List.length: [?] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + List.length(xs) end in

# Extract the head of the list. #
let List.hd: [?] -> ? =
  fun l -> 
    case l  
    | [] => ?
    | x::xs => x end in

# Extract the rest of the list. #
let List.tl: [?] -> [?] =
  fun l ->
    case l 
    | [] => ?
    | x::xs => xs end in

# Determine if a list is empty. #
let List.is_empty: [?] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

let List.nth: ([?], Int) -> ? =
  fun xs, n ->
    case xs, n
    | x::_, 0 => x
    | _::xs, n => List.nth(xs, n - 1)
    | [], _ => ? end in

# Reverse a List. #
let List.rev: [?] -> [?] =
  fun l -> 
    let go: ([?], [?]) -> [?] =
      fun xs, acc -> 
        case xs 
        | [] => acc 
        | x::xs => go(xs, x::acc) end in
   go(l, []) in

# Initialize a list with a given length using an initializer function #
let List.init: (Int, Int -> ?) -> [?] =
  fun len, f ->
    let go: (Int, [?]) -> [?] =
      fun idx, xs ->
        if idx < len 
        then go(idx+ 1, xs @ [f(idx)])   
        else xs in
    go(0, []) in

# Check if two lists are equal #
let List.equal: (? -> Bool, [?], [?]) -> Bool =
  fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => p(x, y) && List.equal(p, xs, ys)
    | _ => false end in

let List.eq = List.equal in

# Reduce a list from the left. #
let List.fold_left: ((?, ?)-> ?, ?, [?])-> ?   =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => List.fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let List.fold_right: ((?, ?)-> ?, [?], ?)-> ? =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, List.fold_right(f, tl, acc)) end in

let List.fold_left2: ((?, ?, ?) -> ?, ?, [?], [?]) -> [?] = 
  fun f, acc, xs, ys ->
    case xs, ys
    | [], [] => acc
    | x::xs, y::ys =>
      List.fold_left2(f, f(acc, x, y), xs, ys)
    | _ => ? end in

let List.fold_right2: ((?, ?, ?) -> ?, [?], [?], ?) -> [?] =
  fun f, acc, xs, ys ->
    case xs, ys
    | [], [] => acc
    | x::xs, y::ys =>
       f(x, y, List.fold_right2(f, xs, ys, acc))
    | _ => ? end in

let List.map: (? -> ?, [?]) -> ? =
  fun f, xs ->
    List.fold_right(fun x, acc -> f(x)::acc, xs, []) in

let List.map2: ((?,?) -> ?, [?], [?]) -> [?] =
  fun f, xs, ys ->
    List.fold_left2(
      fun x, y, acc -> f(x, y)::acc, xs, ys, []) in

# Keep elements that satisfy the test. #
let List.filter: (? -> Bool, [?]) -> [?] =
  fun p, xs ->
    case xs
    | [] => []
    | x::xs =>
      let xs = List.filter(p, xs) in 
      if p(x) then x :: xs else xs end in

let List.append: (([?], [?]) -> [?]) =
  fun xs, ys -> List.fold_right(List.cons, xs, ys) in

let List.concat: [[?]] -> [?] =
  fun xss -> List.fold_right(List.append, xss, [])  in

let List.flatten = List.concat in

let List.mapi: ((Int, ?) -> ?, [?]) -> [?] =
  fun f, xs ->
    let go: ? -> ? = fun idx, xs ->
      case xs
      | [] => []
      | hd::tl => f(idx, hd)::go(idx + 1, tl) end in
    go(0, xs) in

let List.filteri: ((Int, ?) -> Bool, [?]) -> [?] =
  fun f, xs ->
    List.concat(List.mapi(
      fun i, x -> if f(i, x) then [x] else [], xs)) in

let List.exists: (? -> Bool, [?]) -> Bool =
  fun p, xs ->
    case xs
    | [] => false
    | x::xs => p(x) \/ List.exists(p, xs) end in

let List.for_all: (? -> Bool, [?]) -> Bool =
  fun p, xs -> not(List.exists(fun x -> not(p(x)), xs)) in

let List.mem = fun eq, xs, y ->
  List.exists(fun x -> eq(x, y), xs) in


# PASSWORDS MVU #

type PasswordCriteria =
  + RequireUppercase
  + RequireLowercase
  + MinimumLength(Int)
  + RequireNumber
  + RequireSpecialChar in

type PasswordStrength =
  + Weak
  + Moderate
  + Strong in
      
type Password = String in
type Criteria = [PasswordCriteria] in
type Strength = PasswordStrength in
  
type Model = (Password, Criteria, Strength) in
  
let initialModel: Model = (
  "",
  [
    MinimumLength(8),
    RequireUppercase,
    RequireLowercase,
    RequireNumber,
    RequireSpecialChar
  ],
  Weak
) in

type Action =
  + UpdatePassword(String)
  + ClearCriteria
  + AddCriterion(PasswordCriteria)
  + RemoveCriterion(PasswordCriteria) in
    
let meetsMinLength: (String, Int) -> Bool =
  fun password, len ->
    string_length(password) >= len in
  
let hasFromSet: (String, String) -> Bool =
  fun password: Password, set: String ->
    let loop: String -> Bool =
      fun s: String ->
        if string_length(s) == 0 
        then false 
        else
          let first = string_sub(s, 0, 1) in
          if string_contains(set, first) 
          then true 
          else loop(string_sub(s, 1, string_length(s) - 1)) 
  in loop(password)
in

let hasUppercase: String -> Bool =
  fun password: Password ->
    hasFromSet(password, "ABCDEFGHIJKLMNOPQRSTUVWXYZ") in
    
let hasLowercase: Password -> Bool =
  fun password: Password ->
    hasFromSet(password, "abcdefghijklmnopqrstuvwxyz") in
        
let hasNumber: Password -> Bool =
  fun password: Password ->
    hasFromSet(password, "0123456789") in
          
let hasSpecialChar: Password -> Bool =
  fun password: Password ->
    hasFromSet(password, "!@#$%^&*()-_=+[]{}|;:,.<>?") in
  
let meetsCriterion: (Password, PasswordCriteria) -> Bool =
  fun password, criterion ->
    case criterion
    | RequireUppercase => hasUppercase(password)
    | RequireLowercase => hasLowercase(password)
    | MinimumLength(len) => meetsMinLength(password, len)
    | RequireNumber => hasNumber(password)
    | RequireSpecialChar => hasSpecialChar(password) 
  end in

let metCriteria: (Password, [PasswordCriteria]) -> [Bool] =
  fun password, criteria ->
    List.filter(
      fun c: PasswordCriteria -> meetsCriterion(password, c),
      criteria
    ) in
    
let strength_of: Int -> PasswordStrength =
  fun num_criteria_met ->
    case num_criteria_met
    | 0 => Weak
    | 1 => Weak
    | 2 => Weak
    | 3 => Moderate
    | 4 => Strong
    | _ => Strong 
    end in
      
let calculateStrength: (Password, [PasswordCriteria]) -> PasswordStrength =
  fun password, criteria ->
    strength_of(List.length(metCriteria(password, criteria))) in
