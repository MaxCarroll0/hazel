let fst: (?, ?) -> ? = fun a, b -> a in
let snd: (?, ?) -> ? = fun a, b -> b in

let bool_eq: (Bool, Bool) -> Bool =
  fun a, b -> a && b \/ !a && !b in

let List.cons: (?, [?]) -> [?] =
  fun x, xs -> x::xs in

let List.length: [?] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + List.length(xs) end in

let List.equal: (? -> Bool, [?], [?]) -> Bool =
  fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => p(x, y) && List.equal(p, xs, ys)
    | _ => false end in

let List.fold_right: ((?, ?)-> ?, [?], ?)-> ? =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, List.fold_right(f, tl, acc)) end in

let List.append: (([?], [?]) -> [?]) =
  fun xs, ys -> List.fold_right(List.cons, xs, ys) in

let List.concat: [[?]] -> [?] =
  fun xss -> List.fold_right(List.append, xss, [])  in

let List.mapi: ((Int, ?) -> ?, [?]) -> [?] =
  fun f, xs ->
    let go: ? -> ? = fun idx, xs ->
      case xs
      | [] => []
      | hd::tl => f(idx, hd)::go(idx + 1, tl) end in
    go(0, xs) in

let List.filteri: ((Int, ?) -> Bool, [?]) -> [?] =
  fun f, xs ->
    List.concat(List.mapi(
      fun i, x -> if f(i, x) then [x] else [], xs)) in

type Todo = (String, Bool) in

type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String) in

type Update = (Model, Action) -> Model in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
  d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in
