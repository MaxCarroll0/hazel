[{ role = System;
   content =
   "CODE COMPLETION INSTRUCTIONS:\n- Reply with a functional, idiomatic replacement for the program hole marked '??' in the provided program sketch\n- Reply only with a single replacement term for the unqiue distinguished hole marked '??'\n- Reply only with code\n- DO NOT suggest more replacements for other holes in the sketch (marked '?'), or implicit holes\n- DO NOT include the program sketch in your reply\n- DO NOT include a period at the end of your response and DO NOT use markdown\nHAZEL SYNTAX NOTES:\n- Hazel uses C-style function application syntax, with parenthesis around comma-separated arguments\n- Function application is ALWAYS written using parentheses and commas: use 'function(arg1, arg2)'. DO NOT just use spaces between the function name and arguments.\n- Function parameters are ALWAYS commas separated: 'fun arg1, arg2 -> <exp>'. DO NOT use spaces to separate function arguments.\n- There is no dot accessor notation for tuples; DO NOT use tuple.field. use pattern matching for destructuring: let (field, _) = tuple in ...\n- The following ARE NOT Hazel keywords. DO NOT use these keywords: switch, with, of, rec. ALWAYS omit these keywords\n- Pattern matching is ALWAYS written a 'case ... end' expression. Cases MUST END in an 'end' keyword. DO NOT USE any other keyword besides 'case' to do pattern matching.  DO NOT USE a 'with' or 'of' keyword with 'case', just start the list of rules. Pattern matching rules use syntax '| pattern => expression'. Note the '=>' arrow.\n- The ONLY way to define a named function is by using a function expression nested in a let expression like 'let <pat> = fun <pat> -> <exp> in <exp'. There is no support for specifying the function arguments directly as part of the let. DO NOT write function arguments in the let pattern.\n- No 'rec' keyword is necessary for 'let' to define a recursive function. DO NOT use the 'rec' keyword with 'let'.\n- Format the code with proper linebreaks"
   };
  { role = User;
    content =
    "{\nsketch: \nlet List.length: [(String, Bool)]-> Int =\n  fun xs ->\n    ?? end in\n,\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with Int\n,\n}"
    };
  { role = Assistant;
    content = "\ncase xs\n| [] => 0\n| _::xs => 1 + List.length(xs)" };
  { role = User;
    content =
    "{\nsketch: \nlet List.mapi: ((Int, Bool) -> Bool, [Bool]) -> [Bool]=\n  fun f, xs ->\n    let go: (Int, [Bool])-> [Bool] = fun idx, xs ->\n      ?? end in\n    go(0, xs) in\n,\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with [Bool]\n,\n}"
    };
  { role = Assistant;
    content =
    "\ncase xs\n| [] => []\n| hd::tl => f(idx, hd)::go(idx + 1, tl)\n" };
  { role = User;
    content =
    "{\nsketch: \ntype Container =\n  + Pod(Int)\n  + CapsuleCluster(Int, Int) in\nlet total_capacity: Container -> Int =\n  ??\nin\n,\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with (Container -> Int) which references the following definitions:\ntype Container = ? in,\n}"
    };
  { role = Assistant;
    content =
    "\nfun c ->\n    case c\n      | Pod(x) => x\n      | CapsuleCluster(x, y) => x * y\n    end\n"
    };
  { role = User;
    content =
    "{\nsketch: let f = ?? in f(5),\nexpected_ty: Hole ?? can be filled by an expression with any type,\n}"
    };
  { role = Assistant; content = "fun x:Int -> ??" };
  { role = User;
    content =
    "{\nsketch: let get: Option => Int =\n        case Some(5)\n        | Some(x) => ??\n        | None => 0 end,\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with Int\n,\n}"
    };
  { role = Assistant; content = "x" };
  { role = User;
    content =
    "{\nsketch: let num_or_zero = fun maybe_num ->\n case maybe_num\n | Some(num) => ?? \n| None => 0 end,\nexpected_ty: Hole ?? can be filled by an expression with any type,\n}"
    };
  { role = Assistant; content = "num" };
  { role = User;
    content =
    "{\nsketch: let merge_sort: [Int]->[Int] =\n??\nin\nmerge_sort([4,1,3,7,2]),\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with (Int -> Int)\n,\n}"
    };
  { role = Assistant;
    content =
    "fun list ->\nlet split: [Int]->([Int],[Int]) = fun left, right -> ?\nin\nlet merge: ([Int],[Int])->[Int]= ?\nin\nlet merge_sort_helper: [Int]->[Int]= ?\nin\nmerge_sort_helper(list)"
    };
  { role = User;
    content =
    "{\nsketch: type MenuItem =\n+ Breakfast(Int, Int)\n+ Lunch(Float)\nin\nlet per_lunch_unit = 0.95 in\nlet price: MenuItem-> Float   = fun m ->\ncase m\n| Breakfast(x, y) => ??\n| Lunch(f) => f *. per_lunch_unit\nend\nin price(Breakfast(1,2))/.3.,\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with MenuItem which references the following definitions:\ntype MenuItem = ? in,\n}"
    };
  { role = Assistant;
    content =
    "fun m ->\ncase m\n| Breakfast(x, y) => ??\n| Lunch(f) => f *. per_lunch_unit\nend"
    };
  { role = User;
    content =
    "{\nsketch: \nlet List.merge: (( , )->Bool,[ ], [ ]) -> [ ] = fun cmp,left, right ->\ncase left, right\n| [], _ => right\n| _, [] => left\n| h1::t1, h2::t2 =>\nif cmp(h1, h2)\nthen h1 :: List.merge(cmp, t1, right)\nelse h2 :: List.merge(cmp,left, t2)\nend\nin\n\nlet List.sort: ((?, ?) -> Bool, [?]) -> [?] =\nfun cmp, list ->\nlet merge_sort_helper: [?] -> [?] = fun l ->\ncase  l\n| [] => ?\n| [x] => [x]\n| _ => ??\nend\nin merge_sort_helper(list)\nin\ntest 2 == List.nth(List.sort(fun a, b -> a<b, [4,1,3,2]), 1) end\n    ,\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with [?]\n,\n}"
    };
  { role = Assistant;
    content =
    "\nlet mid = List.length(l) / 2 in\nlet left, right = List.take(mid, l), List.drop(mid, l) in\nList.merge(cmp, merge_sort_helper(left), merge_sort_helper(right))\n"
    };
  { role = User;
    content =
    "{\nsketch: # Update the EmojiPaint app model based on an action #\n\nlet update: (Model, Action) -> Model =\n  ??\nin\n,\nexpected_ty: Hole ?? can be filled by an expression with a type consistent with ((Model, Action) -> Model) which references the following definitions:\ntype Col = Int in\ntype Emoji = String in\ntype Row = Int in\ntype Emoji = String in\ntype Emoji = String in\ntype Grid = [[Emoji]] in\ntype Action = (SelectEmoji(Emoji) + StampEmoji((Row, Col)) + ClearCell((Row, Col)) + ClearGrid + FillRow(Row)) in\ntype Model = (Grid, Emoji, [Emoji]) in,\nrelevant_ctx:\n # Consider using these variables relevant to the expected type: #\nlet model_init: Model = ... in\nlet fillRowInGrid: ((Grid, Row, Emoji) -> Grid) = ... in\nlet clearGrid: (Grid -> Grid) = ... in\nlet updateGrid: ((Grid, Row, Col, Emoji) -> Grid) = ... in\nlet string_sub: ((String, Int, Int) -> String) = ... in\nlet string_concat: ((String, [String]) -> String) = ... in\nlet string_trim: (String -> String) = ... in\nlet string_of_bool: (Bool -> String) = ... in,\n}"
    }
  ]