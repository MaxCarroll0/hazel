import AstUtil from "./ast_util"
import AstMk from "./ast_mk"
import Ast from "./ast"
import Int32 from "int32"
import Float32 from "float32"

export let and = (x, y) => {
    if (AstUtil.isConst(x) && AstUtil.isConst(y)) {
        AstUtil.boolToHazel(AstUtil.hazelToBool(x) && AstUtil.hazelToBool(y))
    } else {
        let x = AstMk.convertToBoolLit(x)
        let y = AstMk.convertToBoolLit(y)
        AstMk.mkBinBoolOp(Ast.And, x, y)
    }
}

export let or = (x, y) => {
    if (AstUtil.isConst(x) && AstUtil.isConst(y)) {
        AstUtil.boolToHazel(AstUtil.hazelToBool(x) || AstUtil.hazelToBool(y))
    } else {
        let x = AstMk.convertToBoolLit(x)
        let y = AstMk.convertToBoolLit(y)
        AstMk.mkBinBoolOp(Ast.Or, x, y)
    }
}

let int32operation = (op, func, x, y) => {
    if (AstUtil.isNumber(x) && AstUtil.isNumber(y)) {
        AstUtil.int32ToHazel(
            func(AstUtil.hazelToInt32(x), AstUtil.hazelToInt32(y))
        )
    } else {
        let x = AstMk.convertToIntLit(x)
        let y = AstMk.convertToIntLit(y)
        AstMk.mkBinIntOp(op, x, y)
    }
}

export let plus = (x, y) => int32operation(Ast.Plus, Int32.add, x, y);

export let minus = (x, y) => int32operation(Ast.Minus, Int32.sub, x, y);

export let times = (x, y) => int32operation(Ast.Times, Int32.mul, x, y);

export let divide = (x, y) => int32operation(Ast.Divide, Int32.div, x, y);

let int32compare = (op, func, x, y) => {
    if (AstUtil.isNumber(x) && AstUtil.isNumber(y)) {
        AstUtil.boolToHazel(
            func(AstUtil.hazelToInt32(x), AstUtil.hazelToInt32(y))
        )
    } else {
        let x = AstMk.convertToIntLit(x)
        let y = AstMk.convertToIntLit(y)
        AstMk.mkBinIntOp(op, x, y)
    }
}

export let lessThan = (x, y) => int32compare(Ast.LessThan, Int32.lt, x, y);

export let greaterThan = (x, y) => int32compare(Ast.GreaterThan, Int32.gt, x, y);

export let equals = (x, y) => int32compare(Ast.Equals, Int32.eq, x, y);

let float32operation = (op, func, x, y) => {
    if (AstUtil.isFloat(x) && AstUtil.isFloat(y)) {
        AstUtil.float32ToHazel(
            func(AstUtil.hazelToFloat32(x), AstUtil.hazelToFloat32(y))
        )
    } else {
        let x = AstMk.convertToFloatLit(x)
        let y = AstMk.convertToFloatLit(y)
        AstMk.mkBinFloatOp(op, x, y)
    }
}

export let fplus = (x, y) => float32operation(Ast.FPlus, Float32.add, x, y);

export let fminus = (x, y) => float32operation(Ast.FMinus, Float32.sub, x, y);

export let ftimes = (x, y) => float32operation(Ast.FTimes, Float32.mul, x, y);

export let fdivide = (x, y) => float32operation(Ast.FDivide, Float32.div, x, y);

let float32compare = (op, func, x, y) => {
    if (AstUtil.isFloat(x) && AstUtil.isFloat(y)) {
        AstUtil.boolToHazel(
            func(AstUtil.hazelToFloat32(x), AstUtil.hazelToFloat32(y))
        )
    } else {
        let x = AstMk.convertToFloatLit(x)
        let y = AstMk.convertToFloatLit(y)
        AstMk.mkBinFloatOp(op, x, y)
    }
}

export let fLessThan = (x, y) => float32compare(Ast.FLessThan, Float32.lt, x, y);

export let fGreaterThan = (x, y) => float32compare(Ast.FGreaterThan, Float32.gt, x, y);

export let fEquals = (x, y) => {
    if (AstUtil.isFloat(x) && AstUtil.isFloat(y)) {
        AstUtil.boolToHazel(
            Float32.lte(AstUtil.hazelToFloat32(x), AstUtil.hazelToFloat32(y)) &&
            Float32.gte(AstUtil.hazelToFloat32(x), AstUtil.hazelToFloat32(y))
        )
    } else {
        let x = AstMk.convertToFloatLit(x)
        let y = AstMk.convertToFloatLit(y)
        AstMk.mkBinFloatOp(Ast.FEquals, x, y)
    }
}
