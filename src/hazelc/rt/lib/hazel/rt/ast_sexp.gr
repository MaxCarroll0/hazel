import List from "list"

import Ast from "./ast"

import Sexp from "../../sexplib/sexp"
import * from "../../sexplib/sexpconv"

export let sexpOfVar = sexpOfString

export let sexpOfHoleReason = reason =>
  match (reason) {
    Ast.TypeInconsistent => Sexp.Atom("TypeInconsistent"),
    Ast.WrongLength => Sexp.Atom("WrongLength"),
  }

export let sexpOfMetaVar = sexpOfNumber
export let sexpOfMetaVarInst = sexpOfNumber

export let rec sexpOfHTyp = t =>
  match (t) {
    Ast.Hole => Sexp.Atom("Hole"),
    Ast.Int => Sexp.Atom("Int"),
    Ast.Float => Sexp.Atom("Float"),
    Ast.Bool => Sexp.Atom("Bool"),
    Ast.Arrow(t1, t2) => Sexp.List([Sexp.Atom("Arrow"), sexpOfHTyp(t1), sexpOfHTyp(t2)]),
    Ast.Sum(t1, t2) => Sexp.List([Sexp.Atom("Sum"), sexpOfHTyp(t1), sexpOfHTyp(t2)]),
    Ast.Prod(ts) => Sexp.List([Sexp.Atom("Prod"), ...List.map(t => sexpOfHTyp(t), ts)]),
    Ast.List(t) => Sexp.List([Sexp.Atom("List"), sexpOfHTyp(t)]),
  }

export let sexpOfBinBoolOp = op =>
  match (op) {
    Ast.And => Sexp.Atom("And"),
    Ast.Or => Sexp.Atom("Or"),
  }

export let sexpOfBinIntOp = op =>
  match (op) {
    Ast.Minus => Sexp.Atom("Minus"),
    Ast.Plus => Sexp.Atom("Plus"),
    Ast.Times => Sexp.Atom("Times"),
    Ast.Divide => Sexp.Atom("Divide"),
    Ast.LessThan => Sexp.Atom("LessThan"),
    Ast.GreaterThan => Sexp.Atom("GreaterThan"),
    Ast.Equals => Sexp.Atom("Equals"),
  }

export let sexpOfBinFloatOp = op =>
  match (op) {
    Ast.FMinus => Sexp.Atom("FMinus"),
    Ast.FPlus => Sexp.Atom("FPlus"),
    Ast.FTimes => Sexp.Atom("FTimes"),
    Ast.FDivide => Sexp.Atom("FDivide"),
    Ast.FLessThan => Sexp.Atom("FLessThan"),
    Ast.FGreaterThan => Sexp.Atom("FGreaterThan"),
    Ast.FEquals => Sexp.Atom("FEquals"),
  }

export let rec sexpOfAst = ast =>
  match (ast) {
    Ast.EmptyHole(u, i, sigma) =>
      Sexp.List(
        [
          Sexp.Atom("EmptyHole"),
          sexpOfNumber(u),
          sexpOfNumber(i),
          sexpOfMap(sexpOfVar, sexpOfAst, sigma),
        ]
      ),
    Ast.NonEmptyHole(reason, u, i, sigma, ast) =>
      Sexp.List(
        [
          Sexp.Atom("NonEmptyHole"),
          sexpOfHoleReason(reason),
          sexpOfMetaVar(u),
          sexpOfMetaVarInst(i),
          sexpOfMap(sexpOfVar, sexpOfAst, sigma),
          sexpOfAst(ast),
        ]
      ),
    Ast.Cast(ast, t1, t2) =>
      Sexp.List([Sexp.Atom("Cast"), sexpOfAst(ast), sexpOfHTyp(t1), sexpOfHTyp(t2)]),
    Ast.FailedCast(ast, t1, t2) =>
      Sexp.List([Sexp.Atom("FailedCast"), sexpOfAst(ast), sexpOfHTyp(t1), sexpOfHTyp(t2)]),
    Ast.Ap(fn, arg) => Sexp.List([Sexp.Atom("Ap"), sexpOfAst(fn), sexpOfAst(arg)]),
    Ast.BoolLit(b) => Sexp.List([Sexp.Atom("BoolLit"), sexpOfBool(b)]),
    Ast.IntLit(b) => Sexp.List([Sexp.Atom("IntLit"), sexpOfNumber(b)]),
    Ast.FloatLit(b) => Sexp.List([Sexp.Atom("FloatLit"), sexpOfFloat(b)]),
    Ast.BinBoolOp(op, ast1, ast2) =>
      Sexp.List(
        [Sexp.Atom("BinBoolOp"), sexpOfBinBoolOp(op), sexpOfAst(ast1), sexpOfAst(ast2)]
      ),
    Ast.BinIntOp(op, ast1, ast2) =>
      Sexp.List(
        [Sexp.Atom("BinIntOp"), sexpOfBinIntOp(op), sexpOfAst(ast1), sexpOfAst(ast2)]
      ),
    Ast.BinFloatOp(op, ast1, ast2) =>
      Sexp.List(
        [Sexp.Atom("BinFloatOp"), sexpOfBinFloatOp(op), sexpOfAst(ast1), sexpOfAst(ast2)]
      ),
  }
