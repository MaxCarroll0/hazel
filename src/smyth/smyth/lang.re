/** The syntax of {e Core Smyth}, as defined in {b Figure 3} of the ICFP 2020
    paper. */;

/** The type of hole "names," which is used to identify holes for synthesis. */

type hole_name = int;

/** A map with domain {!hole_name}. */
module Hole_map =
  Map.Make({
    type t = hole_name;
    let compare = Int.compare;
  });

/** An abbreviation for using {!Hole_map}s. */

type hole_map('a) = Hole_map.t('a);

/** Expression types. */

type typ =
  | /** Arrow type */
    TArr(typ, typ)
  | /** Tuple type */
    TTuple(list(typ))
  | /** Datatype */
    TData(string, list(typ))
  | /** Universal quantification */
    TForall(string, typ)
  | /** Type variable */
    TVar(string);

/** Patterns. */

type pat =
  | /** Variable pattern */
    PVar(string)
  | /** Tuple pattern */
    PTuple(list(pat))
  | /** Wildcard pattern */
    PWildcard;

/** The types of valid parameters in a function signature. */

type param =
  | PatParam(pat)
  | TypeParam(string);

/** The types of valid arguments in a function application. */

type exp_arg =
  | EAExp(exp)
  | EAType(typ)

/** Expressions.

    - If the "name" field of a fix expression is [None], then the fix is a
      non-recursive lambda.

    - A "special" application is one that has recursion generated by synthesis
      from {!Term_gen}. This feature is tracked only for end-user purposes; it
      can be used, for example, in a "recursive window" UI (that only displays
      recursive solutions) or in benchmarks for the "Top-1R" (etc.)
      experiments. */
and exp =
  | /** Fix expressions [(name, param, body)]*/
    EFix(
      option(string),
      param,
      exp,
    )
  | /** Applications [(special, head, arg)] */
    EApp(bool, exp, exp_arg)
  | /** Variables */
    EVar(string)
  | /** Tuples */
    ETuple(list(exp))
  | /** Tuple projections [(n, i, arg)] */
    EProj(int, int, exp)
  | /** Constructors [(name, type args, arg)] */
    ECtor(string, list(typ), exp)
  | /** Case expressions [(scrutinee, branches)] */
    ECase(
      exp,
      list((string, (pat, exp))),
    )
  | /** Hole expressions */
    EHole(hole_name)
  | /** Assertions */
    EAssert(exp, exp)
  | /** Type annotations */
    ETypeAnnotation(exp, typ);

/** The types of valid arguments in a result function application. */

type res_arg =
  | RARes(res)
  | RAType(typ)

/** Results.

    - Determinate results: [RFix, RTuple, RCtor].
    - Indeterminate results: [RHole, RApp, RProj, RCase, RCtorInverse]. */
and res =
  | /** Fix closures */
    RFix(env, option(string), param, exp)
  | /** Tuples */
    RTuple(list(res))
  | /** Constructors */
    RCtor(string, res)
  | /** Hole closures */
    RHole(env, hole_name)
  | /** Applications */
    RApp(res, res_arg)
  | /** Tuple projections */
    RProj(int, int, res)
  | /** Case results */
    RCase(env, res, list((string, (pat, exp))))
  | /** Inverse constructors */
    RCtorInverse(string, res)

/** Environments: [(result bindings, type variable bindings)]. */
and env = (list((string, res)), list((string, typ)));

/** Binding specifications. */

type bind_spec =
  | NoSpec /* No bindspec */
  | Rec(string) /* "Recursive" bindspec */
  | Arg(string) /* "Argument of" bindspec */
  | Dec(string); /* "Decreasing on" bindspec */

/** Type bindings for type contexts. */

type type_binding = (string, (typ, bind_spec));

/** Polymorphic name "bindings" for type contexts (just the name of the variable
    is needed in the type context). */

type poly_binding = string;

/** Type contexts. */

type type_ctx = (list(type_binding), list(poly_binding));

/** Datatype contexts. */

type datatype_ctx = list((string, (list(string), list((string, typ)))));

/** Hole contexts: [(hole name, type context, typ, decrease requirement, match depth)].
    The "decrease requirement", if present, is a function that expressions must
    be decreasing on to fill the hole in question. */

type hole_ctx = list((hole_name, (type_ctx, typ, option(string), int)));

/** "Simple" values. */

type value =
  | /** Tuples */
    VTuple(list(value))
  | /** Constructors */
    VCtor(string, value);

/** Examples. */

type example =
  | /** Tuples */
    ExTuple(list(example))
  | /** Constructors */
    ExCtor(string, example)
  | /** Input-output examples */
    ExInputOutput(value, example)
  | /** Top (wildcard) examples */
    ExTop;

/** Example constraints, also known as "worlds." */

type world = (env, example);

/** Multiple example constraints (worlds). */

type worlds = list(world);

/** Hole fillings. */

type hole_filling = hole_map(exp);

/** Unfilled holes, also known as "unsolved constraints." */

type unsolved_constraints = hole_map(worlds);

/** Constraints. */

type constraints = (hole_filling, unsolved_constraints);

/** Resumption assertions, as defined in {b Figure 7}. */

type resumption_assertion = (res, value);

/** Multiple resumption assertions. */

type resumption_assertions = list(resumption_assertion);

/** Term generation ("guessing") goals. */

type gen_goal = (type_ctx, typ, option(string));

/** Basic synthesis goals. */

type synthesis_goal = (gen_goal, worlds);

/** Full notion of synthesis goals, including a hole name. */

type fill_goal = (hole_name, synthesis_goal);

/** Parameters for synthesis. */

type synthesis_params = {
  max_scrutinee_size: int,
  max_match_depth: int,
  max_term_size: int,
};
