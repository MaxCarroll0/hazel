Sort,Constructor Form,Term Form,Precedence
Jdmt,Val(Exp),Exp val,post. 9
Jdmt,"Eval(Exp, Exp)",Exp $> Exp,l s. 0
Jdmt,"Entail(Prop, Prop)",Prop |- Prop,l s. 0
Jdmt,Parens(Jdmt),( Jdmt ),
Prop,"HasTy(Exp, Typ)",Exp : Typ,l s. 1
Prop,"Syn(Exp, Typ)",Exp <= [Typ],l s. 1
Prop,"Ana(Exp, Typ)",Exp => [Typ],l s. 1
Prop,<Atom>,<Var>,-
Prop,"And(Prop, Prop)",Prop /\ Prop,l s. 3
Prop,"Or(Prop, Prop)",Prop \/ Prop,l s. 2
Prop,"Implies(Prop, Prop)",Prop ==> Prop,l s. 1
Prop,"Cons(Prop, Prop)","Prop, Prop",l s. 0
Prop,Truth,-,atom
Prop,Falsity,-,atom
Prop,Parens(Prop),( Prop ),
Exp - short for ALFA_Exp,<NumLit>,<Int>,pre. 7
Exp,Neg(Exp),- Exp,pre. 6
Exp,"Plus(Exp, Exp)",Exp + Exp,l s. 3
Exp,"Minus(Exp, Exp)",Exp - Exp,l s. 3
Exp,"Times(Exp, Exp)",Exp * Exp,l s. 4
Exp,"Eq(Exp, Exp)",Exp =? Exp,l s. 2
Exp,"Lt(Exp, Exp)",Exp < Exp,l s. 2
Exp,"Gt(Exp, Exp)",L ( Exp),l s. 2
Exp,True,-,-
Exp,False,-,-
Exp,"IF(Exp, Exp, Exp)",if Exp then Exp else Exp,pre. 0
Exp,<Var>,<Var>,atom
Exp,"Let(Pat, Exp, Exp)",let Pat = Exp in Exp,-
Exp,"LetPair(Pat, Pat, Exp, Exp)","let <( <Pat , Pat> )> = Exp in Exp",
Exp,"Fix(Pat, Exp)",fix Pat -> Exp,-
Exp,"Fun(Pat, Exp)",fun Pat -> Exp,-
Exp,"Ap(Exp, Exp)",Exp ( Exp ),-
Exp,"Pair(Exp, Exp)","(Exp, Exp)",-
Exp,PrjL(Exp),Exp .fst,post. 7
Exp,PrjR(Exp),Exp .snd,post. 7
Exp,InjL,L,pre. 5
Exp,InjR(Exp),R Exp,pre. 5
Exp,"Case(Exp, Pat, Exp, Pat, Exp)",case Exp of L Pat -> Exp else R Pat -> Exp,pre. 0
Exp,Roll(Exp),roll(Exp),-
Exp,Unroll(Exp),unroll(Exp),-
Exp,Parens(Exp),( Exp ),
Exp,"Ap(InjL, Exp)",L ( Exp ),
Pat - short for ALFA_Pat,<Pat>,<Var>,-
Pat,"PatAnn(Pat, Typ)",Pat : Typ,-
Pat,"Pair(Pat, Pat)","Pat, Pat",
Pat,Parens(Pat),( Pat ),
Typ - short for ALFA_Typ,Num,-,-
Typ,Bool,-,-
Typ,"Arrow(Typ, Typ)",Typ -> Typ,-
Typ,"Prod(Typ, Typ)",Typ * Typ,-
Typ,Unit,1,-
Typ,Unit,Unit,
Typ,"Sum(Typ, Typ)",Typ + Typ,-
Typ,<TVar>,<Var>,-
Typ,"Rec(TPat, Typ)",rec TPat -> Typ,-
Typ,Parens(Typ),( Typ ),
TPat - short for ALFA_TPat,<TPat>,<Var>,-