open Sexplib.Std;

/* TYPE_PROVENANCE: From whence does an unknown type originate?
   Is it generated from an unannotated pattern variable (SynSwitch),
   a pattern variable annotated with a type hole (TypeHole), or
   generated by an internal judgement (Internal)? */
[@deriving (show({with_path: false}), sexp, yojson)]
type type_provenance =
  | SynSwitch
  | TypeHole
  | Internal;

/* TYP.T: Hazel types */
[@deriving (show({with_path: false}), sexp, yojson)]
type t =
  | Unknown(type_provenance)
  | Int
  | Float
  | Bool
  | String
  | Var(string)
  | List(t)
  | Arrow(t, t)
  | Sum(sum_map)
  | Prod(list(t))
  | Rec(Token.t, t)
and sum_map = VarMap.t_(option(t));

[@deriving (show({with_path: false}), sexp, yojson)]
type sum_entry = (Token.t, option(t));

let sum_entry = (t: Token.t, tags: sum_map): option(sum_entry) =>
  List.find_map(
    fun
    | (tag, typ) when tag == t => Some((tag, typ))
    | _ => None,
    tags,
  );

let ana_sum = (tag: Token.t, sm: sum_map, ty_ana: t): option(t) =>
  /* Returns the type of a tag if that tag is given a type by the sum
     type ty_ana having tags as variants. If tag is a nullart constructor,
     ty_ana itself is returned; otherwise an arrow from tag's parameter
     type to ty_ana */
  switch (sum_entry(tag, sm)) {
  | Some((_, Some(ty_in))) => Some(Arrow(ty_in, ty_ana))
  | Some((_, None)) => Some(ty_ana)
  | None => None
  };

/* SOURCE: Hazel type annotated with a relevant source location.
   Currently used to track match branches for inconsistent
   branches errors, but could perhaps be used more broadly
   for type debugging UI. */
[@deriving (show({with_path: false}), sexp, yojson)]
type source = {
  id: int,
  ty: t,
};

[@deriving (show({with_path: false}), sexp, yojson)]
type self_error =
  | Multi
  | NoFun(t)
  | Free
  | FreeTag;

/* SELF: The (synthetic) type information derivable from a term
   in isolation, using the typing context but not the syntactic
   context. This can either be Free (no type, in the case of
   unbound/undefined names), Joined (a list of types, possibly
   inconsistent, generated by branching forms like ifs,
   matches, and list literals), or Just a regular type. */
[@deriving (show({with_path: false}), sexp, yojson)]
type self =
  | Just(t)
  // TODO: make joined apply only to inconsistent types; rename NoJoin, move to Self
  | Joined(t => t, list(source))
  | Self(self_error);

/* MODE: The (analytic) type information derived from a term's
   syntactic context. This can either Syn (no type expectation),
   or Ana (a type expectation). It is conjectured [citation needed]
   that the Syn mode is functionally indistinguishable from
   Ana(Unknown(SynSwitch)), and that this type is thus vestigial. */
[@deriving (show({with_path: false}), sexp, yojson)]
type mode =
  | SynFun
  | Syn
  | Ana(t);

/* Strip location information from a list of sources */
let source_tys = List.map((source: source) => source.ty);

/* How type provenance information should be collated when
   joining unknown types. This probably requires more thought,
   but right now TypeHole strictly predominates over Internal
   which strictly predominates over SynSwitch. */
let join_type_provenance =
    (p1: type_provenance, p2: type_provenance): type_provenance =>
  switch (p1, p2) {
  | (TypeHole, TypeHole | Internal | SynSwitch)
  | (Internal | SynSwitch, TypeHole) => TypeHole
  | (Internal, Internal | SynSwitch)
  | (SynSwitch, Internal) => Internal
  | (SynSwitch, SynSwitch) => SynSwitch
  };

/* MATCHED JUDGEMENTS: Note that matched judgements work
   a bit different than hazel2 here since hole fixing is
   implicit. Somebody should check that what I'm doing
   here actually makes sense -Andrew */

let matched_arrow: t => (t, t) =
  fun
  | Arrow(ty_in, ty_out) => (ty_in, ty_out)
  | Unknown(prov) => (Unknown(prov), Unknown(prov))
  | _ => (Unknown(Internal), Unknown(Internal));

let matched_arrow_mode: mode => (mode, mode) =
  fun
  | SynFun
  | Syn => (Syn, Syn)
  | Ana(ty) => {
      let (ty_in, ty_out) = matched_arrow(ty);
      (Ana(ty_in), Ana(ty_out));
    };

let matched_prod_mode = (mode: mode, length): list(mode) =>
  switch (mode) {
  | Ana(Prod(ana_tys)) when List.length(ana_tys) == length =>
    List.map(ty => Ana(ty), ana_tys)
  | Ana(Unknown(prod)) => List.init(length, _ => Ana(Unknown(prod)))
  | _ => List.init(length, _ => Syn)
  };

let matched_list: t => t =
  fun
  | List(ty) => ty
  | Unknown(prov) => Unknown(prov)
  | _ => Unknown(Internal);

let matched_list_mode: mode => mode =
  fun
  | SynFun
  | Syn => Syn
  | Ana(ty) => Ana(matched_list(ty));

let ap_mode: mode = SynFun;

/* Legacy code from HTyp */

let precedence_Prod = 1;
let precedence_Arrow = 2;
let precedence_Sum = 3;
let precedence_const = 4;
let precedence = (ty: t): int =>
  switch (ty) {
  | Int
  | Float
  | Bool
  | String
  | Unknown(_)
  | Var(_)
  | Rec(_)
  | Sum(_)
  | List(_) => precedence_const
  | Prod(_) => precedence_Prod
  | Arrow(_, _) => precedence_Arrow
  };

let var_eq = (d, n1, n2) =>
  //TODO: shadowing?
  switch (List.assoc_opt(n1, d), List.assoc_opt(n2, d)) {
  | _ when n1 == n2 => true //TODO: get rid of this?
  | (Some(n), _) when n == n2 => true
  | (_, Some(n)) when n1 == n => true
  | _ => false
  };

/* equality
   At the moment, this coincides with default equality,
   but this will change when polymorphic types are implemented */
let rec eq = (~d=[], t1: t, t2: t): bool => {
  let eq' = eq(~d);
  switch (t1, t2) {
  | (Int, Int) => true
  | (Int, _) => false
  | (Float, Float) => true
  | (Float, _) => false
  | (Bool, Bool) => true
  | (Bool, _) => false
  | (String, String) => true
  | (String, _) => false
  | (Unknown(_), Unknown(_)) => true
  | (Unknown(_), _) => false
  | (Arrow(t1_1, t1_2), Arrow(t2_1, t2_2)) =>
    eq'(t1_1, t2_1) && eq'(t1_2, t2_2)
  | (Arrow(_), _) => false
  | (Prod(tys1), Prod(tys2)) => List.equal(eq', tys1, tys2)
  | (Prod(_), _) => false
  | (List(t1), List(t2)) => eq'(t1, t2)
  | (List(_), _) => false
  | (Sum(sm1), Sum(sm2)) => Util.TagMap.equal(opt_eq(~d), sm1, sm2)
  | (Sum(_), _) => false
  | (Var(n1), Var(n2)) => var_eq(d, n1, n2)
  | (Var(_), _) => false
  | (Rec(x1, t1), Rec(x2, t2)) => eq(t1, t2, ~d=[(x1, x2), ...d])
  | (Rec(_), _) => false
  };
}
and opt_eq = (~d, t1: option(t), t2: option(t)): bool =>
  switch (t1, t2) {
  | (None, None) => true
  | (Some(t1), Some(t2)) => eq(~d, t1, t2)
  | _ => false
  };

let rec free_vars = (~bound=[], ty: t): list(Token.t) =>
  switch (ty) {
  | Unknown(_)
  | Int
  | Float
  | Bool
  | String => []
  | Var(v) => List.mem(v, bound) ? [] : [v]
  | List(ty) => free_vars(~bound, ty)
  | Arrow(t1, t2) => free_vars(~bound, t1) @ free_vars(~bound, t2)
  | Sum(sm) =>
    Util.ListUtil.flat_map(
      fun
      | None => []
      | Some(typ) => free_vars(~bound, typ),
      List.map(snd, sm),
    )
  | Prod(tys) => List.concat(List.map(free_vars(~bound), tys))
  | Rec(x, ty) => free_vars(~bound=[x] @ bound, ty)
  };

let rec subst = (s: t, x: Token.t, ty: t) => {
  switch (ty) {
  | Int => Int
  | Float => Float
  | Bool => Bool
  | String => String
  | Unknown(prov) => Unknown(prov)
  | Arrow(ty1, ty2) => Arrow(subst(s, x, ty1), subst(s, x, ty2))
  | Prod(tys) => Prod(List.map(subst(s, x), tys))
  | Sum(sm) => Sum(Util.TagMap.map(Option.map(subst(s, x)), sm))
  | Rec(y, ty) when Token.compare(x, y) == 0 => Rec(y, ty)
  | Rec(y, ty) => Rec(y, subst(s, x, ty))
  | List(ty) => List(subst(s, x, ty))
  | Var(y) => Token.compare(x, y) == 0 ? s : Var(y)
  };
};
