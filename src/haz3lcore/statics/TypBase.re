open Sexplib.Std;

/* TYPE_PROVENANCE: From whence does an unknown type originate?
   Is it generated from an unannotated pattern variable (SynSwitch),
   a pattern variable annotated with a type hole (TypeHole), or
   generated by an internal judgement (Internal)? */
[@deriving (show({with_path: false}), sexp, yojson)]
type type_provenance =
  | SynSwitch
  | TypeHole
  | Internal;

/* TYP.ann: any type annotation */
[@deriving (show({with_path: false}), sexp, yojson)]
type ann('item) = {
  item: 'item,
  name: string,
};

/* TYP.T: Hazel types */
[@deriving (show({with_path: false}), sexp, yojson)]
type t =
  | Unknown(type_provenance)
  | Int
  | Float
  | Bool
  | String
  | Var(ann(option(int)))
  | List(t)
  | Arrow(t, t)
  | Sum(sum_map)
  | Prod(list(t))
  | Rec(ann(t))
  | Forall(ann(t))
and sum_map = VarMap.t_(option(t));

[@deriving (show({with_path: false}), sexp, yojson)]
type sum_entry = (Token.t, option(t));

/* MODE: The (analytic) type information derived from a term's
   syntactic context. This can either Syn (no type expectation),
   or Ana (a type expectation). It is conjectured [citation needed]
   that the Syn mode is functionally indistinguishable from
   Ana(Unknown(SynSwitch)), and that this type is thus vestigial. */
[@deriving (show({with_path: false}), sexp, yojson)]
type mode =
  | SynFun
  | SynTypFun
  | Syn
  | Ana(t);

let rec incr = (~depth=0, ty: t, i: int): t => {
  let recurse = incr(~depth);
  switch (ty) {
  | Var({item: Some(k), name}) =>
    Var({
      item:
        /* The variable is bound and should not be incremented if k < depth */
        Some(k < depth ? k : i + k),
      name,
    })
  | Var(_) => ty
  | List(ty) => List(recurse(ty, i))
  | Arrow(ty1, ty2) => Arrow(recurse(ty1, i), recurse(ty2, i))
  | Sum(map) =>
    Sum(
      VarMap.map(
        ((_, ty)) =>
          switch (ty) {
          | Some(ty) => Some(recurse(ty, i))
          | None => None
          },
        map,
      ),
    )
  | Prod(tys) => Prod(List.map(ty => recurse(ty, i), tys))
  | Rec({item, name}) => Rec({item: incr(~depth=depth + 1, item, i), name})
  | Forall({item, name}) =>
    Forall({item: incr(~depth=depth + 1, item, i), name})
  | Int => Int
  | Float => Float
  | Bool => Bool
  | String => String
  | Unknown(_) => ty
  };
};
